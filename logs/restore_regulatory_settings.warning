Syzkaller hit 'WARNING in restore_regulatory_settings' bug.

random: crng init done
random: 7 urandom warning(s) missed due to ratelimiting
------------[ cut here ]------------
Unexpected user alpha2: A
WARNING: CPU: 0 PID: 321 at net/wireless/reg.c:417 is_user_regdom_saved net/wireless/reg.c:415 [inline]
WARNING: CPU: 0 PID: 321 at net/wireless/reg.c:417 restore_alpha2 net/wireless/reg.c:2921 [inline]
WARNING: CPU: 0 PID: 321 at net/wireless/reg.c:417 restore_regulatory_settings+0x1c1/0x10d0 net/wireless/reg.c:3013
Kernel panic - not syncing: panic_on_warn set ...

CPU: 0 PID: 321 Comm: kworker/u4:3 Not tainted 4.15.18+ #3
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
Workqueue: events_power_efficient crda_timeout_work
Call Trace:
 __dump_stack lib/dump_stack.c:17 [inline]
 dump_stack+0x8a/0xb9 lib/dump_stack.c:58
 panic+0x1bf/0x3ad kernel/panic.c:185
 __warn.cold.9+0x20/0x51 kernel/panic.c:552
 report_bug+0x1f7/0x270 lib/bug.c:186
 fixup_bug arch/x86/kernel/traps.c:178 [inline]
 fixup_bug arch/x86/kernel/traps.c:173 [inline]
 do_error_trap+0x1a0/0x270 arch/x86/kernel/traps.c:296
 invalid_op+0x1b/0x40 arch/x86/entry/entry_64.S:967
RIP: 0010:is_user_regdom_saved net/wireless/reg.c:415 [inline]
RIP: 0010:restore_alpha2 net/wireless/reg.c:2921 [inline]
RIP: 0010:restore_regulatory_settings+0x1c1/0x10d0 net/wireless/reg.c:3013
RSP: 0018:ffff88805f997cb8 EFLAGS: 00010282
RAX: 0000000000000000 RBX: 0000000000000041 RCX: 0000000000000007
RDX: 0000000000000000 RSI: ffffffff81293c4e RDI: ffff888060c1f370
RBP: 0000000000000001 R08: fffffbfff0c27e4e R09: fffffbfff0c27e49
R10: fffffbfff0c27e4d R11: ffffffff8613f268 R12: 0000000000000000
R13: 0000000000000000 R14: ffff888060810900 R15: ffff88805fc6cc00
 crda_timeout_work+0x2f/0x50 net/wireless/reg.c:512
 process_one_work+0x67e/0xf80 kernel/workqueue.c:2147
 worker_thread+0xe1/0xfc0 kernel/workqueue.c:2281
 kthread+0x2f0/0x3b0 kernel/kthread.c:240
 ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:408
Dumping ftrace buffer:
   (ftrace buffer empty)
Kernel Offset: disabled
Rebooting in 1 seconds..


Syzkaller reproducer:
# {Threaded:false Collide:false Repeat:false RepeatTimes:0 Procs:1 Sandbox: Fault:false FaultCall:-1 FaultNth:0 Leak:false NetInjection:false NetDevices:false NetReset:false Cgroups:false BinfmtMisc:false CloseFDs:false KCSAN:false DevlinkPCI:false UseTmpDir:false HandleSegv:true Repro:false Trace:false}
r0 = socket$nl_generic(0x10, 0x3, 0x10)
r1 = syz_genetlink_get_family_id$nl80211(&(0x7f0000001c80)='nl80211\x00')
sendmsg$NL80211_CMD_REQ_SET_REG(r0, &(0x7f00000003c0)={0x0, 0x0, &(0x7f0000000380)={&(0x7f0000000340)={0x24, r1, 0x1, 0x0, 0x0, {}, [@NL80211_ATTR_REG_ALPHA2={0x6, 0x21, 'a\x00'}, @NL80211_ATTR_USER_REG_HINT_TYPE={0x8}]}, 0x24}}, 0x0)


C reproducer:
// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE

#include <endian.h>
#include <errno.h>
#include <setjmp.h>
#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>

#include <linux/genetlink.h>
#include <linux/netlink.h>

static __thread int skip_segv;
static __thread jmp_buf segv_env;

static void segv_handler(int sig, siginfo_t* info, void* ctx)
{
  uintptr_t addr = (uintptr_t)info->si_addr;
  const uintptr_t prog_start = 1 << 20;
  const uintptr_t prog_end = 100 << 20;
  if (__atomic_load_n(&skip_segv, __ATOMIC_RELAXED) &&
      (addr < prog_start || addr > prog_end)) {
    _longjmp(segv_env, 1);
  }
  exit(sig);
}

static void install_segv_handler(void)
{
  struct sigaction sa;
  memset(&sa, 0, sizeof(sa));
  sa.sa_handler = SIG_IGN;
  syscall(SYS_rt_sigaction, 0x20, &sa, NULL, 8);
  syscall(SYS_rt_sigaction, 0x21, &sa, NULL, 8);
  memset(&sa, 0, sizeof(sa));
  sa.sa_sigaction = segv_handler;
  sa.sa_flags = SA_NODEFER | SA_SIGINFO;
  sigaction(SIGSEGV, &sa, NULL);
  sigaction(SIGBUS, &sa, NULL);
}

#define NONFAILING(...)                                                        \
  {                                                                            \
    __atomic_fetch_add(&skip_segv, 1, __ATOMIC_SEQ_CST);                       \
    if (_setjmp(segv_env) == 0) {                                              \
      __VA_ARGS__;                                                             \
    }                                                                          \
    __atomic_fetch_sub(&skip_segv, 1, __ATOMIC_SEQ_CST);                       \
  }

static long syz_genetlink_get_family_id(volatile long name)
{
  char buf[512] = {0};
  struct nlmsghdr* hdr = (struct nlmsghdr*)buf;
  struct genlmsghdr* genlhdr = (struct genlmsghdr*)NLMSG_DATA(hdr);
  struct nlattr* attr = (struct nlattr*)(genlhdr + 1);
  hdr->nlmsg_len =
      sizeof(*hdr) + sizeof(*genlhdr) + sizeof(*attr) + GENL_NAMSIZ;
  hdr->nlmsg_type = GENL_ID_CTRL;
  hdr->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
  genlhdr->cmd = CTRL_CMD_GETFAMILY;
  attr->nla_type = CTRL_ATTR_FAMILY_NAME;
  attr->nla_len = sizeof(*attr) + GENL_NAMSIZ;
  NONFAILING(strncpy((char*)(attr + 1), (char*)name, GENL_NAMSIZ));
  struct iovec iov = {hdr, hdr->nlmsg_len};
  struct sockaddr_nl addr = {0};
  addr.nl_family = AF_NETLINK;
  int fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_GENERIC);
  if (fd == -1) {
    return -1;
  }
  struct msghdr msg = {&addr, sizeof(addr), &iov, 1, NULL, 0, 0};
  if (sendmsg(fd, &msg, 0) == -1) {
    close(fd);
    return -1;
  }
  ssize_t n = recv(fd, buf, sizeof(buf), 0);
  close(fd);
  if (n <= 0) {
    return -1;
  }
  if (hdr->nlmsg_type != GENL_ID_CTRL) {
    return -1;
  }
  for (; (char*)attr < buf + n;
       attr = (struct nlattr*)((char*)attr + NLMSG_ALIGN(attr->nla_len))) {
    if (attr->nla_type == CTRL_ATTR_FAMILY_ID)
      return *(uint16_t*)(attr + 1);
  }
  return -1;
}

uint64_t r[2] = {0xffffffffffffffff, 0x0};

int main(void)
{
  syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 3ul, 0x32ul, -1, 0);
  install_segv_handler();
  intptr_t res = 0;
  res = syscall(__NR_socket, 0x10ul, 3ul, 0x10ul);
  if (res != -1)
    r[0] = res;
  NONFAILING(memcpy((void*)0x20001c80, "nl80211\000", 8));
  res = syz_genetlink_get_family_id(0x20001c80);
  if (res != -1)
    r[1] = res;
  NONFAILING(*(uint64_t*)0x200003c0 = 0);
  NONFAILING(*(uint32_t*)0x200003c8 = 0);
  NONFAILING(*(uint64_t*)0x200003d0 = 0x20000380);
  NONFAILING(*(uint64_t*)0x20000380 = 0x20000340);
  NONFAILING(*(uint32_t*)0x20000340 = 0x24);
  NONFAILING(*(uint16_t*)0x20000344 = r[1]);
  NONFAILING(*(uint16_t*)0x20000346 = 1);
  NONFAILING(*(uint32_t*)0x20000348 = 0);
  NONFAILING(*(uint32_t*)0x2000034c = 0);
  NONFAILING(*(uint8_t*)0x20000350 = 0x1b);
  NONFAILING(*(uint8_t*)0x20000351 = 0);
  NONFAILING(*(uint16_t*)0x20000352 = 0);
  NONFAILING(*(uint16_t*)0x20000354 = 6);
  NONFAILING(*(uint16_t*)0x20000356 = 0x21);
  NONFAILING(memcpy((void*)0x20000358, "a\000", 2));
  NONFAILING(*(uint16_t*)0x2000035c = 8);
  NONFAILING(*(uint16_t*)0x2000035e = 0x9a);
  NONFAILING(*(uint32_t*)0x20000360 = 0);
  NONFAILING(*(uint64_t*)0x20000388 = 0x24);
  NONFAILING(*(uint64_t*)0x200003d8 = 1);
  NONFAILING(*(uint64_t*)0x200003e0 = 0);
  NONFAILING(*(uint64_t*)0x200003e8 = 0);
  NONFAILING(*(uint32_t*)0x200003f0 = 0);
  syscall(__NR_sendmsg, r[0], 0x200003c0ul, 0ul);
  return 0;
}
